#' Extract the feasible parameter sets meeting some criteria.
#'
#' Extract the feasible (or \emph{behavioural}) parameter sets meeting some
#' criteria. These could be used as a feasible set or to estimate prediction
#' quantiles according to the GLUE (Generalised Likelihood Uncertainty
#' Estimation) method.
#'
#' @importFrom stats update
#' @importFrom Hmisc wtd.quantile
#'
#' @aliases defineFeasibleSet defineFeasibleSet.hydromad
#' defineFeasibleSet.default
#' @param x in the \code{hydromad} method this is a \code{\link{hydromad}}
#' model object which has been run through either \code{\link{fitBySampling}}
#' or \code{\link{fitByDream}} to generate a large number of random parameter
#' sets with associated objective function scores.  In the \code{default}
#' method, the first argument (\code{x}) is a matrix of parameter values
#' corresponding to the objective function values \code{objseq}.
#' @param ...  extra arguments to the \code{hydromad} method are passed on to
#' the \code{default} method. Extra arguments to the \code{default} method will
#' result in an error.
#' @param thin interval between samples for results from DREAM.  As it is a
#' Markov Chain Monte Carlo method, the sequences should be thinned first to
#' remove autocorrelation and achieve an efficient sample of the parameter
#' distributions. The default thinning interval \code{NA} uses the empirical
#' autocorrelation.  See \code{window.mcmc}.
#' @param model the \code{hydromad} model object to be used to run simulations.
#' Does not apply to the \code{hydromad} method.
#' @param objseq objective function values corresponding to the parameter sets
#' \code{x}. This does not apply to the \code{hydromad} method, where it is
#' assumed that the objective function values have already been calculated.
#' Note that \code{objseq} can be omitted if not using the
#' \code{target.coverage} or \code{threshold} arguments (i.e. if just defining
#' an error criterion with \code{frac.within, within.rel, within.abs}), so the
#' original simulation run is not necessary.
#' @param frac.within,within.abs,within.rel model simulations are only retained
#' in the feasible set if some fraction \code{frac.within} of the simulated
#' values are within a fraction \code{within.rel} of the observed values OR
#' within an absolute difference of \code{within.abs} (typically mm/day).
#' @param groups,FUN \code{groups} is an optional grouping variable, of the
#' same length as the observed data in \code{model}, used to aggregate the
#' observed and fitted time series. The function \code{FUN} is applied to each
#' group. In this case, the error criteria \code{frac.within, within.rel,
#' within.abs} are evaluated on the aggregated values, not the raw time series.
#' Also \code{target.coverage} applies to the aggregated values.  Typically
#' \code{groups} would be generated by \code{\link{cut.Date}} (for regular time
#' periods) or \code{\link{eventseq}} (for events).  Note that the
#' \code{feasible.bounds} (e.g. for plotting) in this case will be an
#' aggregated time series, it will not correspond to the original time index.
#' Use \code{update} or \code{predict} to generate bounds on the original time
#' index.
#' @param target.coverage fraction of the observed values to be contained
#' within the overall ranges of simulated values (minimum and maximum on each
#' time step) from the feasible set of parameters. Note, this does not refer to
#' the \code{glue.quantiles} values, but to the overall maximum and minimum.
#' The simulated values can be within the tolerance limit of observed values
#' given by \code{within.abs} to count as coverage.
#' @param threshold value of the objective function (the objective function
#' used to generate \code{objseq}) used to define the feasible set: all
#' parameter sets above this threshold value will be kept.  Also this
#' \code{threshold} value is subtracted from the objective function values to
#' calculate weights when \code{glue.quantiles} is given. If left as
#' \code{-Inf}, it will be set to the minimum objective function value in the
#' final feasible set.
#' @param glue.quantiles if specified, these GLUE quantiles of the ensemble
#' simulations will be calculated and stored. They can be extracted with
#' \code{fitted} and shown in \code{xyplot}. The quantiles are calcualted using
#' the \code{\link[Hmisc]{wtd.quantile}} function, and weighted according to
#' \code{objseq} - \code{threshold}. If \code{glue.quantiles} is left as
#' \code{c(0,1)} then the overall minimum and maximum simulated values are
#' taken on each time step, which is faster.
#' @return a modified version of \code{model}, with added elements
#' \code{feasible.set}, \code{feasible.scores}, \code{feasible.fitted},
#' \code{glue.quantiles} and \code{feasible.threshold}.  Can be passed to
#' \code{xyplot}, \code{fitted}, \code{predict}, \code{update}, \code{coef},
#' and \code{print}.
#' @author Felix Andrews \email{felix@@nfrac.org}
#' @seealso \code{\link{predict.hydromad}}, \code{update.hydromad},
#' \code{\link{fitBySampling}}, \code{\link{fitByDream}}
#' @keywords ts
#' @examples
#'
#' data(Queanbeyan)
#' ts74 <- window(Queanbeyan, start = "1974-01-01", end = "1976-12-01")
#' mod <- hydromad(ts74, routing = "expuh", rfit = list("inverse", order = c(2, 1)))
#' mod <- update(mod,
#'   sma = "cwi",
#'   tw = c(0, 100), f = c(0, 8), loss = c(-0.1, 0.1)
#' )
#'
#' ## Calculate the set of simulations within 15% error (or 1 mm/day) 90% of time.
#' ## In this case we do not need to calculate objective function values
#' ## beforehand. For GLUE quantiles, however, need to give 'objective'.
#' psets <- parameterSets(coef(mod), samples = 300)
#' feas <- defineFeasibleSet(psets,
#'   model = mod,
#'   frac.within = 0.9, within.rel = 0.15, within.abs = 1
#' )
#'
#' ## How many of the 300 possible parameter sets were retained?
#' nrow(coef(feas, feasible.set = TRUE))
#'
#' ## View ranges of parameters in feasible set
#' feas
#'
#' ## Plot simulation bounds
#' xyplot(feas, feasible.bounds = TRUE, cut = 3)
#'
#' ## Generate set of simulations with NSE > 0.5, for GLUE.
#' ## First, need to calculate objective function values:
#' fit <- fitBySampling(mod, samples = 300, objective = hmadstat("r.squared"))
#' ## Calculate 5 percent and 95 percent GLUE quantiles (i.e. weighted).
#' fitglu <- defineFeasibleSet(fit,
#'   threshold = 0.5,
#'   glue.quantiles = c(0.05, 0.95)
#' )
#' ## Coverage of the GLUE quantile simulations (within 0.1 mm/day)
#' sim <- fitted(fitglu, feasible.bounds = TRUE)
#' head(sim)
#' mean((sim[, 1] < observed(fitglu) + 0.1) &
#'   (sim[, 2] > observed(fitglu) - 0.1))
#'
#' ## Or - keep adding parameter sets until we reach a target coverage:
#' ## Calculate 5 percent and 95 percent GLUE quantiles (i.e. weighted).
#' fitglu <- defineFeasibleSet(fit,
#'   target.coverage = 0.9,
#'   glue.quantiles = c(0.05, 0.95)
#' )
#' ## Coverage of the GLUE quantile simulations (within 0.1 mm/day)
#' ## (not to be confused with the target.coverage to define overall feasible set)
#' sim <- fitted(fitglu, feasible.bounds = TRUE)
#' mean((sim[, 1] < observed(fitglu) + 0.1) &
#'   (sim[, 2] > observed(fitglu) - 0.1))
#'
#' ## Plot simulated GLUE quantiles
#' xyplot(fitglu, feasible.bounds = TRUE, cut = 3)
#' xyplot(fitglu,
#'   feasible.bounds = TRUE, cut = 3,
#'   scales = list(y = list(log = TRUE))
#' )
#' ## Summarise size of the simulation bounds: lower as fraction of upper
#' summary(coredata(sim[, 1] / sim[, 2]))
#'
#' ## Simulate on a new data period
#' newglu <- update(fitglu,
#'   newdata = window(Queanbeyan,
#'     start = "1980-01-01", end = "1982-01-01"
#'   ),
#'   glue.quantiles = c(0.05, 0.95)
#' )
#' ## The new period is very dry, all model simulations overestimate flow.
#' xyplot(newglu, feasible.bounds = TRUE, cut = 3)
#' ## Coverage of the GLUE quantile simulations (within 0.1 mm/day)
#' sim <- fitted(newglu, feasible.bounds = TRUE)
#' mean((sim[, 1] < observed(newglu) + 0.1) &
#'   (sim[, 2] > observed(newglu) - 0.1))
#' @export
defineFeasibleSet <- function(x, ...) {
  UseMethod("defineFeasibleSet")
}


#' @rdname defineFeasibleSet
#' @export
defineFeasibleSet.hydromad <-
  function(x, ..., thin = NA) {
    x <- update(x, feasible.set = NULL)
    if (inherits(x$fit.result, "dream")) {
      result <- x$fit.result
      ## extract last half of Sequences (assumed to have converged)
      mcmc <- window(result)
      logp <- coda::as.mcmc(window(result$hist.logp, start = start(mcmc)))
      ## thin the sequences to remove autocorrelation (more efficient samples)
      if (is.na(thin)) {
        effsz <- coda::effectiveSize(mcmc)
        thin <- 2 * ceiling(max(nrow(mcmc[[1]]) / effsz))
      }
      mcmc <- window(mcmc, thin = thin)
      logp <- window(logp, thin = thin)
      ## stack all parallel MCMC chains into one
      psets <- as.matrix(mcmc)
      objseq <- as.vector(logp)
    } else {
      result <- x$fit.result
      objseq <- result$objseq
      psets <- result$psets
      if (is.null(objseq) || is.null(psets)) {
        stop(paste(
          "this function only works on results from fitByDream() or fitBySampling()",
          "(or other methods generating fit.result$objseq and fit.result$psets)"
        ))
      }
    }
    defineFeasibleSet.default(psets, model = x, objseq = objseq, ...)
  }



#' @rdname defineFeasibleSet
#' @export
defineFeasibleSet.default <-
  function(x, model,
           objseq = rep(1, NROW(x)),
           frac.within = 0,
           within.rel = 0.01,
           within.abs = 0.1,
           groups = NULL, FUN = sum,
           target.coverage = 1,
           threshold = -Inf,
           glue.quantiles = c(0, 1),
           ...) {
    psets <- x
    stopifnot(length(objseq) == NROW(x))
    ## throw an error if any extra arguments
    if (length(list(...)) > 1) {
      stop(
        "unrecognised arguments: ",
        paste(names(list(...)), collapse = ",")
      )
    }
    ## avoid running multiple simulations in every update()!
    model$feasible.set <- NULL
    model$feasible.scores <- NULL
    model$feasible.fitted <- NULL
    ## can use less memory if only estimating max/min bounds
    boundsOnly <- isTRUE(all.equal(glue.quantiles, c(0, 1)))
    ## extract observed data to check coverage of uncertainty bounds
    obs <- observed(model, all = TRUE)
    ## optional aggregation
    doaggr <- identity
    if (!is.null(groups)) {
      doaggr <- function(x) {
        eventapply(x, groups, FUN = FUN)
      }
    }
    obs <- doaggr(obs)
    ## order parameter sets by objective function value
    ordlik <- order(objseq, decreasing = TRUE)
    objseq <- objseq[ordlik]
    psets <- psets[ordlik, , drop = FALSE]
    ## tolerances for each time step
    obs.tol <- pmax(abs(obs * within.rel), within.abs)

    sims <- sim.lower <- sim.upper <- NULL
    ok <- rep(FALSE, length(objseq))

    for (i in 2:length(objseq)) {
      thisPars <- as.list(psets[i, ])
      thisVal <- objseq[i]
      if (!is.finite(thisVal)) {
        next
      }
      ## don't expand feasible set beyond the threshold objective (if given)
      if (thisVal < threshold) {
        break
      }
      ok[i] <- TRUE
      ## simulate
      xsim <- fitted(update(model, newpars = thisPars), all = TRUE)
      if (is.null(xsim)) stop("can not simulate; were all parameters given?")
      xsim <- doaggr(xsim)
      ## check what fraction of this simulation is within given tolerances
      if (frac.within > 0) {
        this.ok <- abs(xsim - obs < obs.tol)
        this.frac.within <- mean(this.ok[-(1:model$warmup)], na.rm = TRUE)
        if (this.frac.within < frac.within) {
          ok[i] <- FALSE
          next
        }
      }
      if (is.null(sim.lower)) {
        sim.lower <- sim.upper <- xsim
      }
      sim.lower <- pmin(sim.lower, xsim)
      sim.upper <- pmax(sim.upper, xsim)
      if (boundsOnly == FALSE) {
        sims <- cbind(sims, coredata(xsim))
      }
      ## check coverage of cumulative set of simulations
      if (target.coverage < 1) {
        isinside <- (sim.lower - within.abs < obs) & (obs < sim.upper + within.abs)
        cover <- mean(isinside[-(1:model$warmup)], na.rm = TRUE)
        if (cover > target.coverage) {
          break
        }
      }
    }
    model$feasible.set <- as.matrix(psets[ok, , drop = FALSE])
    model$feasible.scores <- objseq[ok]
    if (boundsOnly) {
      model$feasible.fitted <- cbind(
        lower = sim.lower,
        upper = sim.upper
      )
    } else {
      glue.quantiles <- sort(glue.quantiles)
      if (is.infinite(threshold)) {
        threshold <- min(model$feasible.scores, na.rm = TRUE)
      }
      weights <- model$feasible.scores - threshold
      weights <- weights / sum(weights, na.rm = TRUE)
      bounds <-
        t(apply(sims, 1, safe.wtd.quantile,
          weights = weights,
          probs = glue.quantiles, normwt = TRUE
        ))
      colnames(bounds) <- paste("GLUE", glue.quantiles * 100, sep = ".")
      model$feasible.fitted <- zoo(bounds, time(obs))
    }
    model$glue.quantiles <- glue.quantiles
    model$feasible.threshold <- threshold
    model
  }

safe.wtd.quantile <- function(x, ..., probs) {
  if (any(is.finite(x))) {
    wtd.quantile(x, ..., probs = probs)
  } else {
    rep(NA_real_, length(probs))
  }
}
